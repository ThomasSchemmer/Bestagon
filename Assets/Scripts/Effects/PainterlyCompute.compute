#pragma kernel ComputePositions

struct MeshProperties
{
    float3 position;
    float4 quat;
    float4 color;
};

float4x4 TRS;
RWStructuredBuffer<MeshProperties> _Properties;
StructuredBuffer<float3> Vertices;
StructuredBuffer<int> Triangles;
float3 GlobalNormal;

// --------- QUATERNIONS
// https://gist.github.com/mattatz/40a91588d5fb38240403f198a938a593
#define QUATERNION_IDENTITY float4(0, 0, 0, 1)

#ifndef PI
#define PI 3.14159265359f
#endif 

float4 rotate_angle_axis(float angle, float3 axis)
{
    float sn = sin(angle * 0.5);
    float cs = cos(angle * 0.5);
    return float4(axis * sn, cs);
}

float4 from_to_rotation(float3 v1, float3 v2)
{
    float4 q;
    float d = dot(v1, v2);
    if (d < -0.999999)
    {
        float3 right = float3(1, 0, 0);
        float3 up = float3(0, 1, 0);
        float3 tmp = cross(right, v1);
        if (length(tmp) < 0.000001)
        {
            tmp = cross(up, v1);
        }
        tmp = normalize(tmp);
        q = rotate_angle_axis(PI, tmp);
    }
    else if (d > 0.999999)
    {
        q = QUATERNION_IDENTITY;
    }
    else
    {
        q.xyz = cross(v1, v2);
        q.w = 1 + d;
        q = normalize(q);
    }
    return q;
}

// --------- END OF QUATERNIONS

inline float3 GetVertex(int StartId, int Offset)
{
    return Vertices[Triangles[StartId + Offset]];
}

float4 GetCenter(int StartId)
{
    // Use centroid formula
    float3 A = GetVertex(StartId, 0);
    float3 B = GetVertex(StartId, 1);
    float3 C = GetVertex(StartId, 2);
    
    float X = (A.x + B.x + C.x) / 3.0f;
    float Y = (A.y + B.y + C.y) / 3.0f;
    float Z = (A.z + B.z + C.z) / 3.0f;
    
    float3 Center = float3(X, Y, Z);
    return float4(Center, 0);
}

float4 GetNormal(int StartId)
{
    float3 A = GetVertex(StartId, 0);
    float3 B = GetVertex(StartId, 1);
    float3 C = GetVertex(StartId, 2);
    
    float3 AB = B - A;
    float3 AC = C - A;
    
    return float4(cross(AB, AC), 0);
}

[numthreads(64,1,1)]
void ComputePositions (uint3 id : SV_DispatchThreadID)
{
    int StartId = id.x * 3;
    float4 NormalWorld = mul(TRS, GetNormal(StartId));
    float4 CenterWorld = mul(TRS, GetCenter(StartId));
    
    MeshProperties Properties;
    Properties.position = CenterWorld.xyz;
    Properties.color = float4(0.5, 1, 0.5, 1);
    Properties.quat = from_to_rotation(GlobalNormal, -NormalWorld.xyz);
    _Properties[id.x] = Properties;
}
