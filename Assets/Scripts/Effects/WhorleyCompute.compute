/** compute shader to create and normalize a whorley noise from given PointStream
* Influenced (and slightly improved in comparison to) sebastian lagues version
*/

#pragma kernel CreateNoiseTexture
#pragma kernel Clear
#pragma kernel Debug
#pragma kernel Normalize

#define THREAD_AMOUNT 16
#define THREAD_AMOUNT_Z 4

RWStructuredBuffer<float3> points;
RWStructuredBuffer<float3> directions;
RWStructuredBuffer<int> minMax;

RWTexture3D<float4> result;
int directionsCount;
// per dimension!
float pointCount;
uint4 size;
uint4 amountGroups;
static const int minMaxAccuracy = 1000000;

#define TOTAL_POINT_COUNT (pointCount * pointCount * pointCount)


float GetMinDistanceForPixel(uint3 pixel){
    //we could check every other pixel for distance, but if we arrange them in a grid
    //we can only check the adjacent grid spaces
    uint3 gridPos = (uint3)(pixel / (float3)size * pointCount);

    float minDistance = 999999;
    for (int i = 0; i < directionsCount; i++) {  
        int3 nPos = gridPos + directions[i];  
        
        uint3 wrappedNPos = (uint3)(nPos + (int3)pointCount) % (uint3)pointCount;

        uint index = wrappedNPos.z * pointCount * pointCount + wrappedNPos.y * pointCount + wrappedNPos.x;
        int3 pointLocation = points[index];
        int3 offset;
        offset.x = nPos.x >= (int)pointCount || nPos.x < 0 ? (int)(directions[i].x * size.x) : 0;
        offset.y = nPos.y >= (int)pointCount || nPos.y < 0 ? (int)(directions[i].y * size.y) : 0;
        offset.z = nPos.z >= (int)pointCount || nPos.z < 0 ? (int)(directions[i].z * size.z) : 0;
        int3 wrappedPixel = pointLocation + offset;

        // bring from 0..pixel to 0..1
        float dist = distance(pixel, wrappedPixel) / (float)size;
        minDistance = min(minDistance, dist);
    }
    
    return sqrt(minDistance);
}

[numthreads(THREAD_AMOUNT, THREAD_AMOUNT, THREAD_AMOUNT_Z)]
void CreateNoiseTexture (uint3 ID : SV_DispatchThreadID)
{
    float value = GetMinDistanceForPixel(ID); 
    /*
    float scale = 1;
    float factor = 1;

    for (int i = 0; i < 0; i++){
        scale *= 2;
        factor *= 0.5;
        float noise = GetMinDistanceForPixel(ID * scale);
        value += noise * factor;
    }
    */

    int parsedValue = value * minMaxAccuracy;
    InterlockedMin(minMax[0], parsedValue);
    InterlockedMax(minMax[1], parsedValue);

    result[ID] = float4(value, value, value, 1);
}

[numthreads(THREAD_AMOUNT, THREAD_AMOUNT, THREAD_AMOUNT_Z)]
void Normalize (uint3 ID : SV_DispatchThreadID)
{
    float minValue = (float)minMax[0] / minMaxAccuracy;
    float maxValue = (float)minMax[1] / minMaxAccuracy;
    float value = result[ID].r; 

    value = (value - minValue) / (maxValue - minValue);
    value = clamp(1 - value, 0, 1);

    result[ID] = float4(value, value, value, 1);
}

[numthreads(THREAD_AMOUNT, THREAD_AMOUNT, THREAD_AMOUNT_Z)]
void Clear (uint3 ID : SV_DispatchThreadID)
{
    result[ID] = float4(0, 0, 0, 1);
}

[numthreads(1, 1, 1)]
void Debug (uint3 ID : SV_DISPATCHTHREADID)
{
    for (int i = 0; i < TOTAL_POINT_COUNT; i++){ 
        result[points[i]] = 1;
    }
}