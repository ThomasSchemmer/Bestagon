#pragma kernel NoiseLand

#include "Assets/Materials/Shaders/Util/Util.cginc"

// used as the equivalent to a dic<float2, biome>
struct BiomeMap
{
    float2 Range;
    uint BiomeIndex;
};

int GroupCount;
int Width;
// noise variables
float Seed;
float Scale;
float Factor;
float Offset;
float Amount;
// biome mapping and coloring variables
int TemperatureCount;
int HeightCount;
RWStructuredBuffer<BiomeMap> TemperatureMap;
RWStructuredBuffer<BiomeMap> HeightMap;
Texture2D<float4> BiomeColors;
//output variables
RWStructuredBuffer<float2> Output;
RWTexture2D<float4> Image;

float LandNoise(float3 uv)
{
    float Result = snoise(uv * Scale + Offset);
    
    for (int i = 1; i < Amount; i++)
    {
        Factor *= 0.5;
        Scale *= 2;
        float Noise = snoise(uv * Scale + Offset) * Factor;
        // old range is already from 0..1, if we add another 0..Factor its too much again
        // Simply add both results proportionally
        float Proportion = pow(2, i);
        Result = (Result + Noise) * (Proportion / (Proportion + 1));
    }
    return Result;
}

// layered simplex noise to land
[numthreads(16,16,1)]
void NoiseLand (uint3 ID : SV_DispatchThreadID)
{
    float2 uv = float2(ID.x / (GroupCount * 16.0), ID.y / (GroupCount * 16.0));
    float Height = LandNoise(float3(uv.xy, Seed));
    // bring from -1..1 to 0..1 range
    Height = Height / 2 + 0.5f;
    float Warning = Height > 1 || Height < 0;
    Image[ID.xy] = float4(Height, Warning, 0, 1);
    
    // take uv.y distance to center line as temperature range
    float Temperature = 1 - smoothstep(-0.5, 1.5, abs(0.5 - uv.y + snoise(uv * 20) / 20) * 2.5);
    Image[ID.xy] = float4(Temperature, 0, 0, 1);
    
    int Index = -1;
    for (int i = 0; i < TemperatureCount; i++)
    {
        if (TemperatureMap[i].Range.x < Temperature && TemperatureMap[i].Range.y > Temperature)
        {
            Index = TemperatureMap[i].BiomeIndex;
        }
    }
    for (i = 0; i < HeightCount; i++)
    {
        if (HeightMap[i].Range.x < Height && HeightMap[i].Range.y > Height)
        {
            Index = HeightMap[i].BiomeIndex;
        }
    }
    
    float4 Color = BiomeColors[uv];
    
    
    Image[ID.xy] = BiomeColors[float2(0, Index + 1)];
    

    uint Pos = ID.y * Width + ID.x;
    Output[Pos] = float2(Height, Temperature);
}